// ============================================================================
// Comparium Firestore Security Rules
// ============================================================================
// Deploy with: firebase deploy --only firestore:rules
// Test with: firebase emulators:start --only firestore
//
// PHASE 1: Private user data migration from localStorage
// - Each user can only read/write their own profile
// - Username uniqueness enforced via separate collection
// - All tanks, favorites, and comparison history are private
// ============================================================================

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user owns the resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    // Validate user profile structure on create
    function isValidUserProfile() {
      let data = request.resource.data;
      return data.keys().hasAll(['uid', 'username', 'email', 'created', 'profile'])
             && data.uid is string
             && data.uid == request.auth.uid  // Must match authenticated user
             && data.username is string
             && data.username.size() >= 3
             && data.username.size() <= 30
             && data.email is string
             && data.email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')
             && data.created is string
             && data.profile is map
             && data.profile.keys().hasAll(['favoriteSpecies', 'comparisonHistory', 'tanks'])
             && data.profile.favoriteSpecies is list
             && data.profile.comparisonHistory is list
             && data.profile.tanks is list;
    }

    // Validate user profile structure on update (more lenient)
    function isValidUserUpdate() {
      let data = request.resource.data;
      // Can't change uid, username, email, or created
      return !('uid' in request.resource.data.diff(resource.data).affectedKeys())
             && !('username' in request.resource.data.diff(resource.data).affectedKeys())
             && !('email' in request.resource.data.diff(resource.data).affectedKeys())
             && !('created' in request.resource.data.diff(resource.data).affectedKeys());
    }

    // Validate tank structure
    function isValidTank(tank) {
      return tank.keys().hasAll(['id', 'name', 'size', 'species', 'created'])
             && tank.id is string
             && tank.name is string
             && tank.name.size() >= 1
             && tank.name.size() <= 100
             && tank.size is number
             && tank.size > 0
             && tank.species is list
             && tank.created is string;
    }

    // Validate comparison structure
    function isValidComparison(comparison) {
      return comparison.keys().hasAll(['id', 'date', 'species', 'compatible'])
             && comparison.id is string
             && comparison.date is string
             && comparison.species is list
             && comparison.species.size() >= 2
             && comparison.compatible is bool;
    }

    // Validate species key format (alphanumeric + hyphens/underscores)
    function isValidSpeciesKey(key) {
      return key is string
             && key.size() > 0
             && key.size() <= 100
             && key.matches('^[a-zA-Z0-9_-]+$');
    }

    // ========================================================================
    // USERS COLLECTION (Primary user data)
    // ========================================================================
    // Structure: users/{uid}
    //   - uid: Firebase Auth UID
    //   - username: Unique username (3-30 chars)
    //   - email: User email
    //   - created: ISO-8601 timestamp
    //   - lastLogin: ISO-8601 timestamp
    //   - profile:
    //       - favoriteSpecies: Array of species keys
    //       - comparisonHistory: Array of comparison objects
    //       - tanks: Array of tank objects
    // ========================================================================

    match /users/{uid} {
      // READ: Only the owner can read their own profile
      allow read: if isOwner(uid);

      // CREATE: Only authenticated user can create their own profile
      // - UID must match authenticated user
      // - Profile structure must be valid
      // - Username must be registered in usernames collection first
      allow create: if isOwner(uid)
                       && isValidUserProfile()
                       && exists(/databases/$(database)/documents/usernames/$(request.resource.data.username));

      // UPDATE: Only owner can update their profile
      // - Cannot change uid, username, email, or created timestamp
      // - Can update lastLogin, profile data
      allow update: if isOwner(uid)
                       && isValidUserUpdate();

      // DELETE: Prevent profile deletion (keep for audit trail)
      // If deletion is needed, implement soft-delete flag instead
      allow delete: if false;
    }

    // ========================================================================
    // USERNAMES COLLECTION (Username uniqueness index)
    // ========================================================================
    // Structure: usernames/{username}
    //   - uid: Firebase Auth UID of the owner
    //   - created: ISO-8601 timestamp when username was claimed
    //
    // This collection enforces username uniqueness and allows username->UID lookup
    // ========================================================================

    match /usernames/{username} {
      // READ: Anyone can check if username exists
      // (Needed for registration validation before user is authenticated)
      allow read: if true;

      // CREATE: Only when creating a new user account
      // - Username must be 3-30 characters
      // - UID must match authenticated user
      // - Can only create if it doesn't already exist (Firestore enforces this)
      allow create: if isAuthenticated()
                       && request.resource.data.uid == request.auth.uid
                       && username.size() >= 3
                       && username.size() <= 30
                       && username.matches('^[a-zA-Z0-9_-]+$');

      // UPDATE/DELETE: Never allow changes to usernames
      // If a user wants to change username, implement a manual admin process
      allow update, delete: if false;
    }

    // ========================================================================
    // EMAIL INDEX COLLECTION (Email->UID lookup - Optional)
    // ========================================================================
    // Structure: emails/{email}
    //   - uid: Firebase Auth UID
    //   - created: ISO-8601 timestamp
    //
    // Optional collection for email->UID lookups if needed
    // Firebase Auth already handles email uniqueness
    // ========================================================================

    match /emails/{email} {
      // READ: Only owner can read their own email mapping
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;

      // CREATE: Only when creating a new user account
      allow create: if isAuthenticated()
                       && request.resource.data.uid == request.auth.uid;

      // UPDATE/DELETE: Never allow changes
      allow update, delete: if false;
    }

    // ========================================================================
    // PUBLIC TANKS COLLECTION (Phase 4 - Tank Sharing)
    // ========================================================================
    // Structure: publicTanks/{tankId}
    //   - tankId: Same ID as in users.profile.tanks[]
    //   - userId: Owner's Firebase Auth UID
    //   - username: Denormalized for display
    //   - isPublic: Always true (enforced by rules)
    //   - name, size, sizeUnit, species, plants, coverPhoto, description
    //   - owner: { username, bio, avatarUrl } - denormalized for Phase 4
    //   - stats: { viewCount, likeCount } - ready for Phase 4
    //   - created, sharedAt, updated: timestamps
    //
    // This collection stores denormalized copies of tanks marked as public.
    // Updated by client-side publicTankManager when user toggles tank.isPublic.
    // ========================================================================

    match /publicTanks/{tankId} {
      // READ: Anyone can view public tanks (no authentication required)
      allow read: if true;

      // CREATE: Must be authenticated and set userId to own UID
      // isPublic must be true (enforced - no private tanks in this collection)
      allow create: if isAuthenticated()
                       && request.resource.data.userId == request.auth.uid
                       && request.resource.data.isPublic == true
                       && request.resource.data.tankId is string
                       && request.resource.data.name is string;

      // UPDATE: Only owner can update their own public tanks
      // userId cannot be changed
      allow update: if isAuthenticated()
                       && resource.data.userId == request.auth.uid
                       && request.resource.data.userId == request.auth.uid;

      // DELETE: Only owner can remove their tank from public gallery
      allow delete: if isAuthenticated()
                       && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // POSTS COLLECTION (Phase 4 Full - Community Social)
    // ========================================================================
    // Structure: posts/{postId}
    //   - userId: Author's Firebase Auth UID
    //   - username: Denormalized for display
    //   - visibility: 'public' or 'private'
    //   - type: Post type (text, photo, tank-share, etc.)
    //   - content: Post text content
    //   - created: Timestamp when created
    //   - updated: Timestamp when last modified
    //
    // Public posts are readable by anyone, owner can create/update/delete
    // ========================================================================

    match /posts/{postId} {
      // READ: Public posts visible to everyone, owners can query their own posts
      allow read: if resource.data.visibility == 'public'
                  || (request.auth != null && resource.data.userId == request.auth.uid);

      // CREATE: Must be authenticated and set userId to own UID
      allow create: if request.auth != null &&
                       request.resource.data.userId == request.auth.uid;

      // UPDATE/DELETE: Only owner can modify their own posts
      allow update, delete: if request.auth != null &&
                               request.auth.uid == resource.data.userId;
    }

    // ========================================================================
    // COMMENTS COLLECTION (Phase 4.2 - Comments & Likes)
    // ========================================================================
    // Structure: comments/{commentId}
    //   - userId: Author's Firebase Auth UID
    //   - postId: Reference to parent post
    //   - content: Comment text (1-1000 chars)
    //   - created: Timestamp when created
    //   - replyTo: Optional parent comment ID for nested replies
    //
    // Anyone can read comments, authenticated users can create,
    // only owner can update/delete their own comments
    // ========================================================================

    // Comments on posts
    match /comments/{commentId} {
      // Anyone can read comments on public posts
      allow read: if true;

      // Authenticated users can create comments
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.postId is string
                    && request.resource.data.content is string
                    && request.resource.data.content.size() > 0
                    && request.resource.data.content.size() <= 1000;

      // Only owner can update/delete their comments
      allow update, delete: if request.auth != null
                            && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // LIKES COLLECTION (Phase 4.2 - Comments & Likes)
    // ========================================================================
    // Structure: likes/{likeId}
    //   - likeId format: {userId}_{targetId}_{targetType}
    //   - userId: User who liked
    //   - targetId: ID of post or comment being liked
    //   - targetType: 'post' or 'comment'
    //   - created: Timestamp when liked
    //
    // Anyone can read likes, users can only create/delete their own likes
    // Likes are immutable (no updates allowed)
    // ========================================================================

    // Likes on posts and comments
    // Document ID format: {userId}_{targetId}_{targetType}
    match /likes/{likeId} {
      // Anyone can read likes
      allow read: if true;

      // User can only create likes with their own userId prefix
      allow create: if request.auth != null
                    && likeId.matches(request.auth.uid + '_.*');

      // User can only delete their own likes
      allow delete: if request.auth != null
                    && likeId.matches(request.auth.uid + '_.*');

      // No updates allowed (likes are create/delete only)
      allow update: if false;
    }

    // ========================================================================
    // SPECIES REFERENCE DATABASE (Phase 2)
    // ========================================================================
    // Fish species data - public read, admin-only write
    //
    // ADMIN SETUP:
    // Before running migration scripts, add admin role to your user profile:
    // 1. Go to Firebase Console → Firestore → users collection
    // 2. Find your user document (your UID)
    // 3. Add field: admin: true
    //
    // Then you can run: npm run migrate:fish
    // ========================================================================

    match /species/{speciesId} {
      // Public read for all users (no authentication required)
      allow read: if true;

      // Admin-only writes
      // Checks if user is authenticated AND has admin: true in their profile
      allow write: if isAuthenticated()
                      && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.admin == true;
    }

    // ========================================================================
    // GLOSSARY COLLECTION (Phase 2)
    // ========================================================================
    // Glossary entries - public read, admin-only write
    //
    // Same admin setup as species collection above
    // Then you can run: npm run migrate:glossary
    // ========================================================================

    match /glossary/{termId} {
      // Public read for all users (no authentication required)
      allow read: if true;

      // Admin-only writes
      // Checks if user is authenticated AND has admin: true in their profile
      allow write: if isAuthenticated()
                      && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.admin == true;
    }

    // ========================================================================
    // TANK EVENTS COLLECTION (Phase 1 - Maintenance Tracking)
    // ========================================================================
    // Structure: tankEvents/{eventId}
    //   - userId: Owner's Firebase Auth UID
    //   - tankId: Reference to tank
    //   - type: Event type (waterChange, fishAdded, etc.)
    //   - date: When event occurred
    //   - created: When record was created
    //   - notes: Optional notes
    //   - data: Type-specific data object
    // ========================================================================

    match /tankEvents/{eventId} {
      // READ: Only owner can read their own events
      allow read: if isAuthenticated()
                     && resource.data.userId == request.auth.uid;

      // CREATE: Must be authenticated and set userId to own UID
      allow create: if isAuthenticated()
                       && request.resource.data.userId == request.auth.uid
                       && request.resource.data.tankId is string
                       && request.resource.data.type is string;

      // UPDATE: Only owner can update their own events
      allow update: if isAuthenticated()
                       && resource.data.userId == request.auth.uid
                       && request.resource.data.userId == request.auth.uid;

      // DELETE: Only owner can delete their own events
      allow delete: if isAuthenticated()
                       && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // TANK SCHEDULES COLLECTION (Phase 1 - Recurring Maintenance)
    // ========================================================================
    // Structure: tankSchedules/{scheduleId}
    //   - userId: Owner's Firebase Auth UID
    //   - tankId: Reference to tank
    //   - tankName: Denormalized tank name
    //   - type: Schedule type (waterChange, filterMaintenance, etc.)
    //   - intervalDays: Days between occurrences
    //   - enabled: Whether schedule is active
    //   - lastCompleted: When task was last done
    //   - nextDue: When task is next due
    //   - reminder: Reminder settings object
    //   - notes: Optional notes
    // ========================================================================

    match /tankSchedules/{scheduleId} {
      // READ: Only owner can read their own schedules
      allow read: if isAuthenticated()
                     && resource.data.userId == request.auth.uid;

      // CREATE: Must be authenticated and set userId to own UID
      allow create: if isAuthenticated()
                       && request.resource.data.userId == request.auth.uid
                       && request.resource.data.tankId is string
                       && request.resource.data.type is string
                       && request.resource.data.intervalDays is number
                       && request.resource.data.intervalDays > 0;

      // UPDATE: Only owner can update their own schedules
      allow update: if isAuthenticated()
                       && resource.data.userId == request.auth.uid
                       && request.resource.data.userId == request.auth.uid;

      // DELETE: Only owner can delete their own schedules
      allow delete: if isAuthenticated()
                       && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // NOTIFICATIONS COLLECTION (Phase 2 - Maintenance Notifications)
    // ========================================================================
    // Structure: notifications/{notificationId}
    //   - userId: Recipient's Firebase Auth UID
    //   - type: Notification type (maintenance, system, etc.)
    //   - title: Short title
    //   - body: Description text
    //   - created: Timestamp when created
    //   - read: Whether user has seen it
    //   - dismissed: Whether user dismissed it
    //   - expiresAt: Timestamp for auto-cleanup
    //   - action: Click action (type, url, data)
    //   - source: What triggered this (type, scheduleId, tankId, tankName)
    //
    // NOTE: Notifications are CREATED by Cloud Functions (Admin SDK),
    // which bypasses these rules. Users can only read/update/delete.
    // ========================================================================

    match /notifications/{notificationId} {
      // READ: Only owner can read their own notifications
      allow read: if isAuthenticated()
                     && resource.data.userId == request.auth.uid;

      // CREATE: Blocked for clients - Cloud Functions create notifications
      // (Admin SDK bypasses security rules)
      allow create: if false;

      // UPDATE: Owner can mark as read/dismissed only
      allow update: if isAuthenticated()
                       && resource.data.userId == request.auth.uid
                       && request.resource.data.userId == request.auth.uid
                       && request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['read', 'dismissed']);

      // DELETE: Owner can delete their own notifications
      allow delete: if isAuthenticated()
                       && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // FCM TOKENS COLLECTION (Phase 2 - Push Notifications)
    // ========================================================================
    // Structure: fcmTokens/{tokenHash}
    //   - token: FCM registration token
    //   - userId: Owner's Firebase Auth UID
    //   - device: Device type (web, ios, android)
    //   - browser: Browser name (chrome, firefox, etc.)
    //   - created: Timestamp when token was created
    //   - lastUsed: Timestamp when token was last used
    //   - valid: Whether token is still valid
    //
    // Token hash is used as document ID to prevent duplicates
    // ========================================================================

    match /fcmTokens/{tokenId} {
      // READ: Only owner can read their own tokens
      allow read: if isAuthenticated()
                     && resource.data.userId == request.auth.uid;

      // CREATE: Must be authenticated and set userId to own UID
      allow create: if isAuthenticated()
                       && request.resource.data.userId == request.auth.uid
                       && request.resource.data.token is string
                       && request.resource.data.valid == true;

      // UPDATE: Owner can update their own tokens (e.g., mark as invalid)
      // Only allow updating 'valid' and 'lastUsed' fields
      allow update: if isAuthenticated()
                       && resource.data.userId == request.auth.uid
                       && request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['valid', 'lastUsed']);

      // DELETE: Owner can delete their own tokens
      // Cloud Functions can also delete via Admin SDK (bypasses rules)
      allow delete: if isAuthenticated()
                       && resource.data.userId == request.auth.uid;
    }

    // ========================================================================
    // FOLLOWS COLLECTION (Phase 4.3 - Social Follows)
    // ========================================================================
    // Structure: follows/{followId}
    //   - followId format: {followerId}_{followingId}
    //   - followerId: User who is following
    //   - followingId: User being followed
    //   - created: Timestamp when followed
    //
    // Anyone can read follow relationships (to display follower counts)
    // Users can only create/delete their own follows
    // ========================================================================

    match /follows/{followId} {
      // Anyone can read follows (for follower counts and lists)
      allow read: if true;

      // User can only create follows where they are the follower
      allow create: if request.auth != null
                    && followId.matches(request.auth.uid + '_.*')
                    && request.resource.data.followerId == request.auth.uid;

      // User can only delete their own follows
      allow delete: if request.auth != null
                    && followId.matches(request.auth.uid + '_.*');

      // No updates allowed (follows are create/delete only)
      allow update: if false;
    }

    // ========================================================================
    // BOOKMARKS COLLECTION (Phase 4.3 - Post Bookmarks)
    // ========================================================================
    // Structure: bookmarks/{bookmarkId}
    //   - bookmarkId format: {userId}_{postId}
    //   - userId: User who bookmarked
    //   - postId: Post being bookmarked
    //   - created: Timestamp when bookmarked
    //
    // Bookmarks are private - only the owner can read their own bookmarks
    // ========================================================================

    match /bookmarks/{bookmarkId} {
      // Helper: Check if bookmarkId belongs to current user
      // Format: {userId}_{postId} - so we check if it starts with user's UID
      function isOwnerBookmark() {
        return bookmarkId.matches(request.auth.uid + '_.*');
      }

      // Read: Owner can read their bookmarks
      // Use document ID pattern for single-doc reads (handles non-existent docs)
      // Use data.userId for collection queries
      allow read: if request.auth != null
                  && (isOwnerBookmark() || resource.data.userId == request.auth.uid);

      // Create: Verify both document ID and data match the user
      allow create: if request.auth != null
                    && isOwnerBookmark()
                    && request.resource.data.userId == request.auth.uid;

      // Delete: User can only delete their own bookmarks
      allow delete: if request.auth != null
                    && isOwnerBookmark()
                    && resource.data.userId == request.auth.uid;

      // No updates allowed (bookmarks are create/delete only)
      allow update: if false;
    }

    // ========================================================================
    // DEFAULT: DENY ALL ACCESS
    // ========================================================================
    // Any collection not explicitly defined above is denied by default
    // This is a security best practice
    // ========================================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
